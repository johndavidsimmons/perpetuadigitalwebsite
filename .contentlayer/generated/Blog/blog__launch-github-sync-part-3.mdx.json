{
  "title": "Syncing Adobe Launch/Tags with Github - Part 3: Extracting file contents with the Github API",
  "date": "2033-12-25T00:00:00.000Z",
  "tags": [
    "adobe launch",
    "adobe tags",
    "javascript",
    "github",
    "automation"
  ],
  "draft": false,
  "summary": "How to use Github to build, sync, & deploy custom code directly to Adobe Launch/Tags - Part 3",
  "body": {
    "raw": "\n## So where exactly are we at?\n\n![step 2 aws diagram](https://images.ctfassets.net/on47yk52ubpi/2CDF4GdPg4VFiqtR5DUZN7/53add3ec790634fc61069d60f65dd6ee/2d_launch_github_sync_diagram_step2.png)\n\nIn this step, I am calling an AWS Lambda called _Extract Github Data_ which will get the changed\nfile contents from Github and prepare them to be sent to the Launch API.\n\n## The Push webhook is just a notification\n\nIn my [previous post](https://www.perpetua.digital/blog/launch-github-sync-part-2),\nI showed how to setup Github to\nnotify me that a file update has occurred. When that happens, I check if I need to sync any changes from that update\nto components in Launch (just data elements for now). I also noted that the Github Push webhook doesn't give me the contents\nof a changed file, its just a notification.\nNow that I know a change occurred in a specific file, and that file is in my `dataelements` folder, I can go grab the contents of that file via the Github API.\n\n## Getting the most recent commit\n\nIn order to get thew newest file contents, I need to look at my repo's most recent commit for that\nfile. From my webhook handler, I received all the information I need to look at the commit history using the Github API:\n\n- `modified_data_element_files` an array the names of the data element files that changed\n- `owner` the owner of the repo - an individual or an organization\n- `repo` - the name of of the repo\n\nTo see the commit history of a given file, I can make this call:\n`https://api.github.com/repos/${owner}/${repo}/commits?path=${file}`\n\nTechnically, I could skip this step because the push webhook _does_ send me the most recent commit reference ID (ref) which is what\nI am looking for here in the commit history. However, I went the route of pulling\nthe most recent ref ID its own call for a few reasons:\n\nFirst, I needed to learn how to make authenticated calls to Github with a [Github Personal Access Token (GPAT)](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\nA GPAT is how I will authenticate to the Github API to pull file contents. While my demo repo is public, in reality,\nsomeone using this process will likely be using a private repo so they will need to authenticate. Its also important to use a GPAT because API calls\nwithout one are subject to rate limiting.\n\nSecond, I didn't want to lock the whole flow into _only_ being able to sync the most recent change.\nIf, for example, I wanted to make some sort of rollback functionality, I would only need to refactor this call to do so.\n\nThe first item in the commit history response list will be my most recent commit,\nthe second item will be my second most recent commit, and so on.\nInside the most recent commit, will the ref I am looking for. Using this value,\nI can now make _another_ call the Github API and ask for the most recent version of a specific file,\ncontents and all. The ref value also comes in handy when naming things in Launch like libraries and environments.\n\nYou can see the commit history of a test file here:\n\n[https://api.github.com/repos/perpetua-digital/launch-property/commits?path=dataelements/test.js](https://api.github.com/repos/perpetua-digital/launch-property/commits?path=dataelements/test.js)\n\n## Extracting the important stuff\n\nThe next call(s) will have the following URL structure. All authenticated by a GPAT. The number of calls will be dependent on how many files were changed.\nA call for each file in the `modified_data_element_files` array.\n\n`https://api.github.com/repos/${owner}/${repo}/contents/${file}?ref=${sha}`\n\n`owner`, `repo`, and `file` all came from my Webhook handler API gateway, and `sha` of course comes\nfrom the commit history call above. Assuming I pass this call the most recent ref value, this will give me everything\nI need I know about the newest version of this file and I can start extracting the important stuff.\n\nThe repo API will return my file contents encoded in Base64 so there is an extra step to decode them.\nGiven this file:\n\n![github file with data element id](https://images.ctfassets.net/on47yk52ubpi/3bidY7K9V3oP8ghZUayWV2/ccc20370efa977661549847e24d24f54/Screenshot_2023-04-28_at_12.47.09_PM.png)\n\n```javascript\n// api returns file contents encoded in base64\n// 'Ly8gREU1NGJhMjc0ZjEwYWE0NGNjOTYyYTg5YzM1NTI2MTc3MQpyZXR1cm4g\\nImhlbGxvIHdvcmxkIGdpdGh1YiAzIgo=\\n'\n\n// decode base64 to get file contents\nconst b64EncodedStringFromAPI =\n  'Ly8gREU1NGJhMjc0ZjEwYWE0NGNjOTYyYTg5YzM1NTI2MTc3MQpyZXR1cm4g\\nImhlbGxvIHdvcmxkIGdpdGh1YiAzIgo=\\n'\nconst sourceCode = atob(b64EncodedStringFromAPI)\nconsole.log(sourceCode)\n// '// DE54ba274f10aa44cc962a89c355261771\\nreturn \"hello world github 3\"\\n'\n```\n\nRemember how I was storing data element IDs in comments in Github files? Well, that is going to come in handy right about now.\n\nI went the route of putting the IDs directly in the files because I couldn't think of any other way\nto relate Github files with data element IDs without having to build a database. Of course, if I\nused a database, then I need a front end to interact with it, then I need to host everything, etc. etc.\nYou get what I'm saying. Though, should this project progress past the proof of concept stage,\na front end is likely inevitable, but I digress...\n\nSince Github returns me the entire contents, I need to extract the Data element ID(s) that this file\nshould be synced with and save it/them.\n\nGiven the above Github file, this lambda's entire purpose is to build an array that looks like this:\n\n```javascript\ndata = [\n  {\n    file: 'dataelements/test.js',\n    fileContents: '// DE54ba274f10aa44cc962a89c355261771\\nreturn \"hello world github 3\"\\n',\n    dataElementIds: ['DE54ba274f10aa44cc962a89c355261771'],\n    sha: 'ABC1234....',\n    author_name: 'John Simmons',\n  },\n]\n```\n\nThis final array will contain all the changes that need to be sent to Launch.\n\n## Next up\n\nSo now that I have a bunch of data element IDs and the contents that they need to be updated\nto, its time to talk to Launch. Once the above array is all built. I trigger the 3rd\nlambda which will build my changes into a development library. Finally, something interesting\nis happening!\n",
    "code": "var Component=(()=>{var r=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var f=(t,a)=>()=>(a||t((a={exports:{}}).exports,a),a.exports),g=(t,a)=>{for(var i in a)o(t,i,{get:a[i],enumerable:!0})},c=(t,a,i,n)=>{if(a&&typeof a==\"object\"||typeof a==\"function\")for(let s of m(a))!u.call(t,s)&&s!==i&&o(t,s,{get:()=>a[s],enumerable:!(n=d(a,s))||n.enumerable});return t};var b=(t,a,i)=>(i=t!=null?r(p(t)):{},c(a||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=>c(o({},\"__esModule\",{value:!0}),t);var h=f((G,l)=>{l.exports=_jsx_runtime});var y={};g(y,{default:()=>I,frontmatter:()=>k});var e=b(h()),k={title:\"Syncing Adobe Launch/Tags with Github - Part 3: Extracting file contents with the Github API\",date:\"2033-12-25\",tags:[\"adobe launch\",\"adobe tags\",\"javascript\",\"github\",\"automation\"],draft:!1,summary:\"How to use Github to build, sync, & deploy custom code directly to Adobe Launch/Tags - Part 3\"};function N(t={}){let{wrapper:a}=t.components||{};return a?(0,e.jsx)(a,Object.assign({},t,{children:(0,e.jsx)(i,{})})):i();function i(){let n=Object.assign({h2:\"h2\",a:\"a\",span:\"span\",p:\"p\",img:\"img\",em:\"em\",code:\"code\",ul:\"ul\",li:\"li\",pre:\"pre\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.h2,{id:\"so-where-exactly-are-we-at\",children:[(0,e.jsx)(n.a,{href:\"#so-where-exactly-are-we-at\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"So where exactly are we at?\"]}),(0,e.jsx)(n.p,{children:(0,e.jsx)(n.img,{alt:\"step 2 aws diagram\",src:\"https://images.ctfassets.net/on47yk52ubpi/2CDF4GdPg4VFiqtR5DUZN7/53add3ec790634fc61069d60f65dd6ee/2d_launch_github_sync_diagram_step2.png\"})}),(0,e.jsxs)(n.p,{children:[\"In this step, I am calling an AWS Lambda called \",(0,e.jsx)(n.em,{children:\"Extract Github Data\"}),\" which will get the changed file contents from Github and prepare them to be sent to the Launch API.\"]}),(0,e.jsxs)(n.h2,{id:\"the-push-webhook-is-just-a-notification\",children:[(0,e.jsx)(n.a,{href:\"#the-push-webhook-is-just-a-notification\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"The Push webhook is just a notification\"]}),(0,e.jsxs)(n.p,{children:[\"In my \",(0,e.jsx)(n.a,{href:\"https://www.perpetua.digital/blog/launch-github-sync-part-2\",children:\"previous post\"}),\", I showed how to setup Github to notify me that a file update has occurred. When that happens, I check if I need to sync any changes from that update to components in Launch (just data elements for now). I also noted that the Github Push webhook doesn't give me the contents of a changed file, its just a notification. Now that I know a change occurred in a specific file, and that file is in my \",(0,e.jsx)(n.code,{children:\"dataelements\"}),\" folder, I can go grab the contents of that file via the Github API.\"]}),(0,e.jsxs)(n.h2,{id:\"getting-the-most-recent-commit\",children:[(0,e.jsx)(n.a,{href:\"#getting-the-most-recent-commit\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Getting the most recent commit\"]}),(0,e.jsx)(n.p,{children:\"In order to get thew newest file contents, I need to look at my repo's most recent commit for that file. From my webhook handler, I received all the information I need to look at the commit history using the Github API:\"}),(0,e.jsxs)(n.ul,{children:[(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"modified_data_element_files\"}),\" an array the names of the data element files that changed\"]}),(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"owner\"}),\" the owner of the repo - an individual or an organization\"]}),(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"repo\"}),\" - the name of of the repo\"]})]}),(0,e.jsxs)(n.p,{children:[\"To see the commit history of a given file, I can make this call: \",(0,e.jsx)(n.code,{children:\"https://api.github.com/repos/${owner}/${repo}/commits?path=${file}\"})]}),(0,e.jsxs)(n.p,{children:[\"Technically, I could skip this step because the push webhook \",(0,e.jsx)(n.em,{children:\"does\"}),\" send me the most recent commit reference ID (ref) which is what I am looking for here in the commit history. However, I went the route of pulling the most recent ref ID its own call for a few reasons:\"]}),(0,e.jsxs)(n.p,{children:[\"First, I needed to learn how to make authenticated calls to Github with a \",(0,e.jsx)(n.a,{href:\"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\",children:\"Github Personal Access Token (GPAT)\"}),\". A GPAT is how I will authenticate to the Github API to pull file contents. While my demo repo is public, in reality, someone using this process will likely be using a private repo so they will need to authenticate. Its also important to use a GPAT because API calls without one are subject to rate limiting.\"]}),(0,e.jsxs)(n.p,{children:[\"Second, I didn't want to lock the whole flow into \",(0,e.jsx)(n.em,{children:\"only\"}),\" being able to sync the most recent change. If, for example, I wanted to make some sort of rollback functionality, I would only need to refactor this call to do so.\"]}),(0,e.jsxs)(n.p,{children:[\"The first item in the commit history response list will be my most recent commit, the second item will be my second most recent commit, and so on. Inside the most recent commit, will the ref I am looking for. Using this value, I can now make \",(0,e.jsx)(n.em,{children:\"another\"}),\" call the Github API and ask for the most recent version of a specific file, contents and all. The ref value also comes in handy when naming things in Launch like libraries and environments.\"]}),(0,e.jsx)(n.p,{children:\"You can see the commit history of a test file here:\"}),(0,e.jsx)(n.p,{children:(0,e.jsx)(n.a,{href:\"https://api.github.com/repos/perpetua-digital/launch-property/commits?path=dataelements/test.js\",children:\"https://api.github.com/repos/perpetua-digital/launch-property/commits?path=dataelements/test.js\"})}),(0,e.jsxs)(n.h2,{id:\"extracting-the-important-stuff\",children:[(0,e.jsx)(n.a,{href:\"#extracting-the-important-stuff\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Extracting the important stuff\"]}),(0,e.jsxs)(n.p,{children:[\"The next call(s) will have the following URL structure. All authenticated by a GPAT. The number of calls will be dependent on how many files were changed. A call for each file in the \",(0,e.jsx)(n.code,{children:\"modified_data_element_files\"}),\" array.\"]}),(0,e.jsx)(n.p,{children:(0,e.jsx)(n.code,{children:\"https://api.github.com/repos/${owner}/${repo}/contents/${file}?ref=${sha}\"})}),(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"owner\"}),\", \",(0,e.jsx)(n.code,{children:\"repo\"}),\", and \",(0,e.jsx)(n.code,{children:\"file\"}),\" all came from my Webhook handler API gateway, and \",(0,e.jsx)(n.code,{children:\"sha\"}),\" of course comes from the commit history call above. Assuming I pass this call the most recent ref value, this will give me everything I need I know about the newest version of this file and I can start extracting the important stuff.\"]}),(0,e.jsx)(n.p,{children:\"The repo API will return my file contents encoded in Base64 so there is an extra step to decode them. Given this file:\"}),(0,e.jsx)(n.p,{children:(0,e.jsx)(n.img,{alt:\"github file with data element id\",src:\"https://images.ctfassets.net/on47yk52ubpi/3bidY7K9V3oP8ghZUayWV2/ccc20370efa977661549847e24d24f54/Screenshot_2023-04-28_at_12.47.09_PM.png\"})}),(0,e.jsx)(n.pre,{className:\"language-javascript\",children:(0,e.jsxs)(n.code,{className:\"language-javascript code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token comment\",children:\"// api returns file contents encoded in base64\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token comment\",children:\"// 'Ly8gREU1NGJhMjc0ZjEwYWE0NGNjOTYyYTg5YzM1NTI2MTc3MQpyZXR1cm4g\\\\nImhlbGxvIHdvcmxkIGdpdGh1YiAzIgo=\\\\n'\"}),`\n`]}),(0,e.jsx)(n.span,{className:\"code-line\",children:`\n`}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token comment\",children:\"// decode base64 to get file contents\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" b64EncodedStringFromAPI \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token string\",children:\"'Ly8gREU1NGJhMjc0ZjEwYWE0NGNjOTYyYTg5YzM1NTI2MTc3MQpyZXR1cm4g\\\\nImhlbGxvIHdvcmxkIGdpdGh1YiAzIgo=\\\\n'\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token keyword\",children:\"const\"}),\" sourceCode \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token function\",children:\"atob\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),\"b64EncodedStringFromAPI\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token class-name console\",children:\"console\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(n.span,{className:\"token function method property-access\",children:\"log\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"(\"}),\"sourceCode\",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\")\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token comment\",children:`// '// DE54ba274f10aa44cc962a89c355261771\\\\nreturn \"hello world github 3\"\\\\n'`}),`\n`]})]})}),(0,e.jsx)(n.p,{children:\"Remember how I was storing data element IDs in comments in Github files? Well, that is going to come in handy right about now.\"}),(0,e.jsx)(n.p,{children:\"I went the route of putting the IDs directly in the files because I couldn't think of any other way to relate Github files with data element IDs without having to build a database. Of course, if I used a database, then I need a front end to interact with it, then I need to host everything, etc. etc. You get what I'm saying. Though, should this project progress past the proof of concept stage, a front end is likely inevitable, but I digress...\"}),(0,e.jsx)(n.p,{children:\"Since Github returns me the entire contents, I need to extract the Data element ID(s) that this file should be synced with and save it/them.\"}),(0,e.jsx)(n.p,{children:\"Given the above Github file, this lambda's entire purpose is to build an array that looks like this:\"}),(0,e.jsx)(n.pre,{className:\"language-javascript\",children:(0,e.jsxs)(n.code,{className:\"language-javascript code-highlight\",children:[(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"data \",(0,e.jsx)(n.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"[\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"{\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    file\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token string\",children:\"'dataelements/test.js'\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    fileContents\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token string\",children:`'// DE54ba274f10aa44cc962a89c355261771\\\\nreturn \"hello world github 3\"\\\\n'`}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    dataElementIds\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"[\"}),(0,e.jsx)(n.span,{className:\"token string\",children:\"'DE54ba274f10aa44cc962a89c355261771'\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"]\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    sha\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token string\",children:\"'ABC1234....'\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"    author_name\",(0,e.jsx)(n.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(n.span,{className:\"token string\",children:\"'John Simmons'\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"}\"}),(0,e.jsx)(n.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(n.span,{className:\"code-line\",children:[(0,e.jsx)(n.span,{className:\"token punctuation\",children:\"]\"}),`\n`]})]})}),(0,e.jsx)(n.p,{children:\"This final array will contain all the changes that need to be sent to Launch.\"}),(0,e.jsxs)(n.h2,{id:\"next-up\",children:[(0,e.jsx)(n.a,{href:\"#next-up\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(n.span,{className:\"icon icon-link\"})}),\"Next up\"]}),(0,e.jsx)(n.p,{children:\"So now that I have a bunch of data element IDs and the contents that they need to be updated to, its time to talk to Launch. Once the above array is all built. I trigger the 3rd lambda which will build my changes into a development library. Finally, something interesting is happening!\"})]})}}var I=N;return w(y);})();\n;return Component;"
  },
  "_id": "blog/launch-github-sync-part-3.mdx",
  "_raw": {
    "sourceFilePath": "blog/launch-github-sync-part-3.mdx",
    "sourceFileName": "launch-github-sync-part-3.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/launch-github-sync-part-3"
  },
  "type": "Blog",
  "readingTime": {
    "text": "5 min read",
    "minutes": 4.585,
    "time": 275100,
    "words": 917
  },
  "slug": "launch-github-sync-part-3",
  "toc": [
    {
      "value": "So where exactly are we at?",
      "url": "#so-where-exactly-are-we-at",
      "depth": 2
    },
    {
      "value": "The Push webhook is just a notification",
      "url": "#the-push-webhook-is-just-a-notification",
      "depth": 2
    },
    {
      "value": "Getting the most recent commit",
      "url": "#getting-the-most-recent-commit",
      "depth": 2
    },
    {
      "value": "Extracting the important stuff",
      "url": "#extracting-the-important-stuff",
      "depth": 2
    },
    {
      "value": "Next up",
      "url": "#next-up",
      "depth": 2
    }
  ]
}