{
  "title": "Syncing Adobe Launch/Tags with Github - Part 3: Extracting file contents from the Github API",
  "date": "2033-12-25T00:00:00.000Z",
  "tags": [
    "adobe launch",
    "adobe tags",
    "javascript",
    "github",
    "automation"
  ],
  "draft": false,
  "summary": "How to use Github to build, sync, & deploy custom code directly to Adobe Launch/Tags - Part 3",
  "body": {
    "raw": "\n## REFRESHER ON WHERE WE ARE IN THIS PROCEESSS\n\n## The Push webhook is just a notification\n\nIn my [previous post](https://www.perpetua.digital/blog/launch-github-sync-part-2), I showed how Github is going to\nnotify me that a file update has occurred and I check if I need to sync any changes from that update\nto components in Launch (just data elements for now). I also noted that the Github Push webhook doesn't give me the changed file contents, its just a notification.\nNow that I know a change occurred in a specific file, and that file is in my `dataelements` folder, I can go grab the contents of that file via the Github API.\n\n## Getting the most recent commit\n\nIn order to get file contents, I need to look at my repo's most recent commit. To do that,\nI need to call the Github API. From my webhook handler, I receive all the information I need to do this:\n\n- `modified_data_element_files` an array the names of the data element files that changed\n- `owner` the owner of the repo - an individual or an organization\n- `repo` - the name of of the repo\n\nTo see the commit history of a given file, I can make this call:\n`https://api.github.com/repos/${owner}/${repo}/commits?path=${file}`\n\nTechnically, I _could_ skip this step because the push webhook does send me the most recent commit ID which is what\nI am looking for here in order to pull the most recent file contents. However, I went the route of pulling\nthe most recent ref ID its own call for a few reasons.\n\nFirst, I needed to learn how to make authenticated calls to Github with a Github personal access token [Github Personal Access Token (GPAT)](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).\nA GPAT is how I will authenticate to the Github API to pull file contents. While my demo repo is public, in reality,\nsomeone else using this process will likely be using a private repo so they will need to authenticate. Its also important to use a GPAT because API calls\nwithout one are subject to rate limiting.\n\nSecond, I didn't want to lock the whole flow into _only_ being able to sync the most recent change.\nIf, for example, I wanted to make some sort of rollback functionality, I could adjust _just_ this call to do that\ninstead of having to rewire this lambda and the webhook handler one.\n\nBasically, the API call above will give me the commit history of my repo. The first item in that list will be my most recent commit,\nthe second item will be my second most recent commit, and so on.\nInside the most recent commit, will be REF SHA. Using this value,\nI can now make another call the Github API and ask for the most recent version of a specific file,\ncontents and all. The REF SHA value also comes in handy when naming things in Launch like libraries and environments.\n\n## Extracting the important stuff\n\nThe next call(s) will be to the following URL. All authenticated by a GPAT. The number of calls will be dependent on how many files were changed.\nA call for each file in `modified_data_element_files`\n\n`https://api.github.com/repos/${owner}/${repo}/contents/${file}?ref=${sha}`\n\n`owner`, `repo`, and `file` all came from my Webhook handler API gateway, and `sha` of course comes\nfrom the commit history call above. Assuming I pass this call the most recent `sha` this will give me everything\nI need I know about the newest version of this file and I can start extracting the important stuff.\n\nRemember how I was storing data element IDs in comments in Github files\n\nIMAGE OF GITHUB FILE here\n\nWell, that is going to come in handy here.\n\nSince Github returns me the entire contents, I need to extract the Data element ID(s) that this file\nshould be synced with and save it/them. I went this route because I couldn't think of any other way\nto relate files with data element IDs without having to build a database. Of course, if I\nused a database, then I need a front end to interact with it, then I need to host everything, etc. etc.\nYou get what I'm saying. Though, should this project progress past the proof of concept stage,\na front end is likely inevitable, but I digress...\n\nGiven the following Github file:\n\nIMAGE of github file\n\nThis lambda's entire purpose is to build an array that looks like this:\n\n```javascript\ndata = [\n  {\n    file: 'dataelements/test.js',\n    fileContents: '// DEcb4622986a964ff895f7104b74ec7dec\\nreturn \"CHANGE THIS VALUE\"\\n',\n    dataElementIds: ['DEcb4622986a964ff895f7104b74ec7dec'],\n    sha: 'ABC1234....',\n    author_name: 'John Simmons',\n  },\n]\n```\n\nSo now that I have a bunch of data element IDs and the contents that they need to be updated\nto, its time to talk to Launch. Once this array is all build. I trigger the 3rd and final*ish*\nlambda which will build my changes into a development library. Almost done!\n",
    "code": "var Component=(()=>{var r=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var f=(n,a)=>()=>(a||n((a={exports:{}}).exports,a),a.exports),g=(n,a)=>{for(var i in a)s(n,i,{get:a[i],enumerable:!0})},c=(n,a,i,t)=>{if(a&&typeof a==\"object\"||typeof a==\"function\")for(let o of m(a))!u.call(n,o)&&o!==i&&s(n,o,{get:()=>a[o],enumerable:!(t=d(a,o))||t.enumerable});return n};var b=(n,a,i)=>(i=n!=null?r(p(n)):{},c(a||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),w=n=>c(s({},\"__esModule\",{value:!0}),n);var h=f((A,l)=>{l.exports=_jsx_runtime});var N={};g(N,{default:()=>y,frontmatter:()=>I});var e=b(h()),I={title:\"Syncing Adobe Launch/Tags with Github - Part 3: Extracting file contents from the Github API\",date:\"2033-12-25\",tags:[\"adobe launch\",\"adobe tags\",\"javascript\",\"github\",\"automation\"],draft:!1,summary:\"How to use Github to build, sync, & deploy custom code directly to Adobe Launch/Tags - Part 3\"};function k(n={}){let{wrapper:a}=n.components||{};return a?(0,e.jsx)(a,Object.assign({},n,{children:(0,e.jsx)(i,{})})):i();function i(){let t=Object.assign({h2:\"h2\",a:\"a\",span:\"span\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",em:\"em\",pre:\"pre\"},n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(t.h2,{id:\"refresher-on-where-we-are-in-this-proceesss\",children:[(0,e.jsx)(t.a,{href:\"#refresher-on-where-we-are-in-this-proceesss\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(t.span,{className:\"icon icon-link\"})}),\"REFRESHER ON WHERE WE ARE IN THIS PROCEESSS\"]}),(0,e.jsxs)(t.h2,{id:\"the-push-webhook-is-just-a-notification\",children:[(0,e.jsx)(t.a,{href:\"#the-push-webhook-is-just-a-notification\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(t.span,{className:\"icon icon-link\"})}),\"The Push webhook is just a notification\"]}),(0,e.jsxs)(t.p,{children:[\"In my \",(0,e.jsx)(t.a,{href:\"https://www.perpetua.digital/blog/launch-github-sync-part-2\",children:\"previous post\"}),\", I showed how Github is going to notify me that a file update has occurred and I check if I need to sync any changes from that update to components in Launch (just data elements for now). I also noted that the Github Push webhook doesn't give me the changed file contents, its just a notification. Now that I know a change occurred in a specific file, and that file is in my \",(0,e.jsx)(t.code,{children:\"dataelements\"}),\" folder, I can go grab the contents of that file via the Github API.\"]}),(0,e.jsxs)(t.h2,{id:\"getting-the-most-recent-commit\",children:[(0,e.jsx)(t.a,{href:\"#getting-the-most-recent-commit\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(t.span,{className:\"icon icon-link\"})}),\"Getting the most recent commit\"]}),(0,e.jsx)(t.p,{children:\"In order to get file contents, I need to look at my repo's most recent commit. To do that, I need to call the Github API. From my webhook handler, I receive all the information I need to do this:\"}),(0,e.jsxs)(t.ul,{children:[(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.code,{children:\"modified_data_element_files\"}),\" an array the names of the data element files that changed\"]}),(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.code,{children:\"owner\"}),\" the owner of the repo - an individual or an organization\"]}),(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.code,{children:\"repo\"}),\" - the name of of the repo\"]})]}),(0,e.jsxs)(t.p,{children:[\"To see the commit history of a given file, I can make this call: \",(0,e.jsx)(t.code,{children:\"https://api.github.com/repos/${owner}/${repo}/commits?path=${file}\"})]}),(0,e.jsxs)(t.p,{children:[\"Technically, I \",(0,e.jsx)(t.em,{children:\"could\"}),\" skip this step because the push webhook does send me the most recent commit ID which is what I am looking for here in order to pull the most recent file contents. However, I went the route of pulling the most recent ref ID its own call for a few reasons.\"]}),(0,e.jsxs)(t.p,{children:[\"First, I needed to learn how to make authenticated calls to Github with a Github personal access token \",(0,e.jsx)(t.a,{href:\"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token\",children:\"Github Personal Access Token (GPAT)\"}),\". A GPAT is how I will authenticate to the Github API to pull file contents. While my demo repo is public, in reality, someone else using this process will likely be using a private repo so they will need to authenticate. Its also important to use a GPAT because API calls without one are subject to rate limiting.\"]}),(0,e.jsxs)(t.p,{children:[\"Second, I didn't want to lock the whole flow into \",(0,e.jsx)(t.em,{children:\"only\"}),\" being able to sync the most recent change. If, for example, I wanted to make some sort of rollback functionality, I could adjust \",(0,e.jsx)(t.em,{children:\"just\"}),\" this call to do that instead of having to rewire this lambda and the webhook handler one.\"]}),(0,e.jsx)(t.p,{children:\"Basically, the API call above will give me the commit history of my repo. The first item in that list will be my most recent commit, the second item will be my second most recent commit, and so on. Inside the most recent commit, will be REF SHA. Using this value, I can now make another call the Github API and ask for the most recent version of a specific file, contents and all. The REF SHA value also comes in handy when naming things in Launch like libraries and environments.\"}),(0,e.jsxs)(t.h2,{id:\"extracting-the-important-stuff\",children:[(0,e.jsx)(t.a,{href:\"#extracting-the-important-stuff\",\"aria-hidden\":\"true\",tabIndex:\"-1\",children:(0,e.jsx)(t.span,{className:\"icon icon-link\"})}),\"Extracting the important stuff\"]}),(0,e.jsxs)(t.p,{children:[\"The next call(s) will be to the following URL. All authenticated by a GPAT. The number of calls will be dependent on how many files were changed. A call for each file in \",(0,e.jsx)(t.code,{children:\"modified_data_element_files\"})]}),(0,e.jsx)(t.p,{children:(0,e.jsx)(t.code,{children:\"https://api.github.com/repos/${owner}/${repo}/contents/${file}?ref=${sha}\"})}),(0,e.jsxs)(t.p,{children:[(0,e.jsx)(t.code,{children:\"owner\"}),\", \",(0,e.jsx)(t.code,{children:\"repo\"}),\", and \",(0,e.jsx)(t.code,{children:\"file\"}),\" all came from my Webhook handler API gateway, and \",(0,e.jsx)(t.code,{children:\"sha\"}),\" of course comes from the commit history call above. Assuming I pass this call the most recent \",(0,e.jsx)(t.code,{children:\"sha\"}),\" this will give me everything I need I know about the newest version of this file and I can start extracting the important stuff.\"]}),(0,e.jsx)(t.p,{children:\"Remember how I was storing data element IDs in comments in Github files\"}),(0,e.jsx)(t.p,{children:\"IMAGE OF GITHUB FILE here\"}),(0,e.jsx)(t.p,{children:\"Well, that is going to come in handy here.\"}),(0,e.jsx)(t.p,{children:\"Since Github returns me the entire contents, I need to extract the Data element ID(s) that this file should be synced with and save it/them. I went this route because I couldn't think of any other way to relate files with data element IDs without having to build a database. Of course, if I used a database, then I need a front end to interact with it, then I need to host everything, etc. etc. You get what I'm saying. Though, should this project progress past the proof of concept stage, a front end is likely inevitable, but I digress...\"}),(0,e.jsx)(t.p,{children:\"Given the following Github file:\"}),(0,e.jsx)(t.p,{children:\"IMAGE of github file\"}),(0,e.jsx)(t.p,{children:\"This lambda's entire purpose is to build an array that looks like this:\"}),(0,e.jsx)(t.pre,{className:\"language-javascript\",children:(0,e.jsxs)(t.code,{className:\"language-javascript code-highlight\",children:[(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"data \",(0,e.jsx)(t.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(t.span,{className:\"token punctuation\",children:\"[\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(t.span,{className:\"token punctuation\",children:\"{\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"    file\",(0,e.jsx)(t.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(t.span,{className:\"token string\",children:\"'dataelements/test.js'\"}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"    fileContents\",(0,e.jsx)(t.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(t.span,{className:\"token string\",children:`'// DEcb4622986a964ff895f7104b74ec7dec\\\\nreturn \"CHANGE THIS VALUE\"\\\\n'`}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"    dataElementIds\",(0,e.jsx)(t.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(t.span,{className:\"token punctuation\",children:\"[\"}),(0,e.jsx)(t.span,{className:\"token string\",children:\"'DEcb4622986a964ff895f7104b74ec7dec'\"}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\"]\"}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"    sha\",(0,e.jsx)(t.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(t.span,{className:\"token string\",children:\"'ABC1234....'\"}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"    author_name\",(0,e.jsx)(t.span,{className:\"token operator\",children:\":\"}),\" \",(0,e.jsx)(t.span,{className:\"token string\",children:\"'John Simmons'\"}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(t.span,{className:\"token punctuation\",children:\"}\"}),(0,e.jsx)(t.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(t.span,{className:\"code-line\",children:[(0,e.jsx)(t.span,{className:\"token punctuation\",children:\"]\"}),`\n`]})]})}),(0,e.jsxs)(t.p,{children:[\"So now that I have a bunch of data element IDs and the contents that they need to be updated to, its time to talk to Launch. Once this array is all build. I trigger the 3rd and final\",(0,e.jsx)(t.em,{children:\"ish\"}),\" lambda which will build my changes into a development library. Almost done!\"]})]})}}var y=k;return w(N);})();\n;return Component;"
  },
  "_id": "blog/launch-github-sync-part-3.mdx",
  "_raw": {
    "sourceFilePath": "blog/launch-github-sync-part-3.mdx",
    "sourceFileName": "launch-github-sync-part-3.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/launch-github-sync-part-3"
  },
  "type": "Blog",
  "readingTime": {
    "text": "5 min read",
    "minutes": 4.01,
    "time": 240600,
    "words": 802
  },
  "slug": "launch-github-sync-part-3",
  "toc": [
    {
      "value": "REFRESHER ON WHERE WE ARE IN THIS PROCEESSS",
      "url": "#refresher-on-where-we-are-in-this-proceesss",
      "depth": 2
    },
    {
      "value": "The Push webhook is just a notification",
      "url": "#the-push-webhook-is-just-a-notification",
      "depth": 2
    },
    {
      "value": "Getting the most recent commit",
      "url": "#getting-the-most-recent-commit",
      "depth": 2
    },
    {
      "value": "Extracting the important stuff",
      "url": "#extracting-the-important-stuff",
      "depth": 2
    }
  ]
}