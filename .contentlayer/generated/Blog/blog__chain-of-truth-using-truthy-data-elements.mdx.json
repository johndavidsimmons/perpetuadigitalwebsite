{
  "title": "Fallbacks and Truthy Chains - How I make bullet proof data elements in Launch",
  "date": "2024-11-17T00:00:00.000Z",
  "tags": ["adobe launch", "data collection", "debugging"],
  "draft": false,
  "summary": "How to utilize fallback data elements to make sure you always get the data you need",
  "body": {
    "raw": "\n## The Problem\n\nYou are the admin of a large Launch property used across many different\nURLs or parts of a website. Similar data points come in through different\nmeans depending on which code base you are in, whether the URL was built by\na vendor with a WYSIWYG tool, what version of your data layer the site uses, etc.\nThis is a problem because you need to collect the same data points everywhere\nand populate them into an eVar or XDM field, regardless of where they come from.\n\n## Example\n\nA real-world example of this problem, ironically, comes from a team\nI'm working with that uses Adobe App Builder (was this called Firefly\nat some point?). App Builder uses hashes for page routing but messes up\nour email campaign query parameters, so URLs end up looking like this,\nwith the query string after the hash:\n\n`https://www.example.com/someapp/#/page?utm_campaign=abc123`\n\nThis means that when my Launch property is on this page, the regular\nquery parameter type data element won't work because window.location.search\nis an empty string due to the query string being after the hash.\nSo, I need to devise some logic to check both my regular parameter and,\nif that is undefined, parse it from this hash. Enter the fallback.\n\n## Using Fallbacks\n\nRather than writing custom code into my rule action logic, which\nI will never maintain, I can use a mapping table data element to\nhandle this check for me. Shoutout to the creators of the mapping\ntable extension! I will need three data elements: `utm_campaign_parameter`,\n`utm_campaign_fallback`, and `utm_campaign`.\n\n### utm_campaign_parameter\n\nThis is my standard query parameter data element type from Launch\n\n### utm_campaign_fallback\n\nThis is a custom code data element that parses a malformed url for\nthe utm_campaign query parameter. It might look something like this\n\n```\nreturn new URLSearchParams(window.location.hash.split('?')[1]).get('utm_campaign')\n```\n\n### utm_campaign\n\nThis is the data element I will actually use. It's a mapping table type that\nevaluates the page URL. If I'm on the `someapp` domain using the example URL\nabove, I want to use my `utm_campaign_fallback` data element since I know\nthis domain has malformed query parameters. Otherwise, I will use the\n`utm_campaign_parameter` data element, which should work normally on other\ndomains. I name this data element simply utm_campaign because that's what\nit returns, regardless of the source.\n\nThis works because the mapping table evaluates in order.\nIf `someapp` is found in the URL, the first row returns.\nIf it's not found, my second, more generic case will match,\nand that data element will be returned.\n\n![mapping table](https://images.ctfassets.net/on47yk52ubpi/2usb4YHSfttNT93jIHPUz5/c02c8042686d2cc2ab52a1909f100640/mappingdataelement.png)\n\n<figure>\n  <figcaption>Mapping table, the goat extension</figcaption>\n</figure>\n\n## Truthy Chain\n\nThe second method is for situations where things are a little murkier,\nand you don't know where your data will come from. Say I need to set my\ncampaign parameter. It might be in `utm_campaign`, or it might be another\nparameter. Maybe it comes from a data layer event or a cookie. Who knows?\nEnter what I call the truthy chain.\n\nTruthy chain data elements work like this: I take my known data sources,\norder them by reliability (or just throw them all in and see which one works),\nand return the first one that isn't undefined. Incorporating a truthy\nchain data element into my previous example would look like this.\nAssume here that my campaign variable can be in different query\nparameters or come through various sources.\n\n### campaign data element\n\n```javascript\nconst campaignSources = [\n  _satellite.getVar('other_campaign_parameter'),\n  _satellite.getVar('other_campaign_fallback'),\n  _satellite.getVar('campaign_cookie'),\n  _satellite.getVar('utm_campaign_fallback'),\n  _satellite.getVar('utm_campaign_parameter'),\n  _satellite.getVar('campaign_from_session_storage'),\n  // etc etc\n]\nreturn campaignSources.find((dataElement) => dataElement)\n```\n\nThis data element will iterate through the list and return the first\ntruthy value (not `undefined`). This assumes my property is configured to\nreturn `undefined` for empty data elements instead of empty strings.\n\nSo on my above example URL with the utm_campaign parameter in the hash,\nthe data element `utm_campaign_fallback` is the first data element that contains\na value. So the truthy chain data element will return that one. If the 'campaign_cookie'\ndata element was defined, the truth chain would return that one since it appears in\nthe list ahead of the utm fallback data element.\n\nUsing this approach in a data element keeps the \"checking\" logic out of\nmy action code and allows me to look in multiple places for the same data.\nOf course, the most ideal setup would be to configure the site to send\nconsistent data in the same way every time, but in today's modern society,\nthat's not always possible.\n\nI use this truthy chain data element paradigm a lot. Maybe I should make an extensionâ€¦\n",
    "code": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var g=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),k=(n,t)=>{for(var i in t)c(n,i,{get:t[i],enumerable:!0})},r=(n,t,i,a)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let s of m(t))!u.call(n,s)&&s!==i&&c(n,s,{get:()=>t[s],enumerable:!(a=d(t,s))||a.enumerable});return n};var f=(n,t,i)=>(i=n!=null?h(p(n)):{},r(t||!n||!n.__esModule?c(i,\"default\",{value:n,enumerable:!0}):i,n)),y=n=>r(c({},\"__esModule\",{value:!0}),n);var o=g((x,l)=>{l.exports=_jsx_runtime});var _={};k(_,{default:()=>w,frontmatter:()=>N});var e=f(o()),N={title:\"Fallbacks and Truthy Chains - How I make bullet proof data elements in Launch\",date:\"2024-11-17\",tags:[\"adobe launch\",\"data collection\",\"debugging\"],draft:!1,summary:\"How to utilize fallback data elements to make sure you always get the data you need\"};function b(n={}){let{wrapper:t}=n.components||{};return t?(0,e.jsx)(t,Object.assign({},n,{children:(0,e.jsx)(i,{})})):i();function i(){let a=Object.assign({h2:\"h2\",a:\"a\",span:\"span\",p:\"p\",code:\"code\",h3:\"h3\",pre:\"pre\",img:\"img\"},n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(a.h2,{id:\"the-problem\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#the-problem\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"The Problem\"]}),(0,e.jsx)(a.p,{children:\"You are the admin of a large Launch property used across many different URLs or parts of a website. Similar data points come in through different means depending on which code base you are in, whether the URL was built by a vendor with a WYSIWYG tool, what version of your data layer the site uses, etc. This is a problem because you need to collect the same data points everywhere and populate them into an eVar or XDM field, regardless of where they come from.\"}),(0,e.jsxs)(a.h2,{id:\"example\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#example\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"Example\"]}),(0,e.jsx)(a.p,{children:\"A real-world example of this problem, ironically, comes from a team I'm working with that uses Adobe App Builder (was this called Firefly at some point?). App Builder uses hashes for page routing but messes up our email campaign query parameters, so URLs end up looking like this, with the query string after the hash:\"}),(0,e.jsx)(a.p,{children:(0,e.jsx)(a.code,{children:\"https://www.example.com/someapp/#/page?utm_campaign=abc123\"})}),(0,e.jsx)(a.p,{children:\"This means that when my Launch property is on this page, the regular query parameter type data element won't work because window.location.search is an empty string due to the query string being after the hash. So, I need to devise some logic to check both my regular parameter and, if that is undefined, parse it from this hash. Enter the fallback.\"}),(0,e.jsxs)(a.h2,{id:\"using-fallbacks\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#using-fallbacks\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"Using Fallbacks\"]}),(0,e.jsxs)(a.p,{children:[\"Rather than writing custom code into my rule action logic, which I will never maintain, I can use a mapping table data element to handle this check for me. Shoutout to the creators of the mapping table extension! I will need three data elements: \",(0,e.jsx)(a.code,{children:\"utm_campaign_parameter\"}),\", \",(0,e.jsx)(a.code,{children:\"utm_campaign_fallback\"}),\", and \",(0,e.jsx)(a.code,{children:\"utm_campaign\"}),\".\"]}),(0,e.jsxs)(a.h3,{id:\"utm_campaign_parameter\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#utm_campaign_parameter\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"utm_campaign_parameter\"]}),(0,e.jsx)(a.p,{children:\"This is my standard query parameter data element type from Launch\"}),(0,e.jsxs)(a.h3,{id:\"utm_campaign_fallback\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#utm_campaign_fallback\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"utm_campaign_fallback\"]}),(0,e.jsx)(a.p,{children:\"This is a custom code data element that parses a malformed url for the utm_campaign query parameter. It might look something like this\"}),(0,e.jsx)(a.pre,{children:(0,e.jsx)(a.code,{className:\"code-highlight\",children:(0,e.jsx)(a.span,{className:\"code-line\",children:`return new URLSearchParams(window.location.hash.split('?')[1]).get('utm_campaign')\n`})})}),(0,e.jsxs)(a.h3,{id:\"utm_campaign\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#utm_campaign\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"utm_campaign\"]}),(0,e.jsxs)(a.p,{children:[\"This is the data element I will actually use. It's a mapping table type that evaluates the page URL. If I'm on the \",(0,e.jsx)(a.code,{children:\"someapp\"}),\" domain using the example URL above, I want to use my \",(0,e.jsx)(a.code,{children:\"utm_campaign_fallback\"}),\" data element since I know this domain has malformed query parameters. Otherwise, I will use the \",(0,e.jsx)(a.code,{children:\"utm_campaign_parameter\"}),\" data element, which should work normally on other domains. I name this data element simply utm_campaign because that's what it returns, regardless of the source.\"]}),(0,e.jsxs)(a.p,{children:[\"This works because the mapping table evaluates in order. If \",(0,e.jsx)(a.code,{children:\"someapp\"}),\" is found in the URL, the first row returns. If it's not found, my second, more generic case will match, and that data element will be returned.\"]}),(0,e.jsx)(a.p,{children:(0,e.jsx)(a.img,{alt:\"mapping table\",src:\"https://images.ctfassets.net/on47yk52ubpi/2usb4YHSfttNT93jIHPUz5/c02c8042686d2cc2ab52a1909f100640/mappingdataelement.png\"})}),(0,e.jsx)(\"figure\",{children:(0,e.jsx)(\"figcaption\",{children:\"Mapping table, the goat extension\"})}),(0,e.jsxs)(a.h2,{id:\"truthy-chain\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#truthy-chain\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"Truthy Chain\"]}),(0,e.jsxs)(a.p,{children:[\"The second method is for situations where things are a little murkier, and you don't know where your data will come from. Say I need to set my campaign parameter. It might be in \",(0,e.jsx)(a.code,{children:\"utm_campaign\"}),\", or it might be another parameter. Maybe it comes from a data layer event or a cookie. Who knows? Enter what I call the truthy chain.\"]}),(0,e.jsx)(a.p,{children:\"Truthy chain data elements work like this: I take my known data sources, order them by reliability (or just throw them all in and see which one works), and return the first one that isn't undefined. Incorporating a truthy chain data element into my previous example would look like this. Assume here that my campaign variable can be in different query parameters or come through various sources.\"}),(0,e.jsxs)(a.h3,{id:\"campaign-data-element\",children:[(0,e.jsx)(a.a,{\"aria-hidden\":\"true\",href:\"#campaign-data-element\",tabIndex:\"-1\",children:(0,e.jsx)(a.span,{className:\"icon icon-link\"})}),\"campaign data element\"]}),(0,e.jsx)(a.pre,{className:\"language-javascript\",children:(0,e.jsxs)(a.code,{className:\"code-highlight language-javascript\",children:[(0,e.jsxs)(a.span,{className:\"code-line\",children:[(0,e.jsx)(a.span,{className:\"token keyword\",children:\"const\"}),\" campaignSources \",(0,e.jsx)(a.span,{className:\"token operator\",children:\"=\"}),\" \",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"[\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  _satellite\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"getVar\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token string\",children:\"'other_campaign_parameter'\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  _satellite\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"getVar\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token string\",children:\"'other_campaign_fallback'\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  _satellite\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"getVar\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token string\",children:\"'campaign_cookie'\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  _satellite\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"getVar\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token string\",children:\"'utm_campaign_fallback'\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  _satellite\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"getVar\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token string\",children:\"'utm_campaign_parameter'\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  _satellite\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"getVar\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token string\",children:\"'campaign_from_session_storage'\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\",\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[\"  \",(0,e.jsx)(a.span,{className:\"token comment\",children:\"// etc etc\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"]\"}),`\n`]}),(0,e.jsxs)(a.span,{className:\"code-line\",children:[(0,e.jsx)(a.span,{className:\"token keyword control-flow\",children:\"return\"}),\" campaignSources\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\".\"}),(0,e.jsx)(a.span,{className:\"token function method property-access\",children:\"find\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\"(\"}),(0,e.jsx)(a.span,{className:\"token parameter\",children:\"dataElement\"}),(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),\" \",(0,e.jsx)(a.span,{className:\"token operator arrow\",children:\"=>\"}),\" dataElement\",(0,e.jsx)(a.span,{className:\"token punctuation\",children:\")\"}),`\n`]})]})}),(0,e.jsxs)(a.p,{children:[\"This data element will iterate through the list and return the first truthy value (not \",(0,e.jsx)(a.code,{children:\"undefined\"}),\"). This assumes my property is configured to return \",(0,e.jsx)(a.code,{children:\"undefined\"}),\" for empty data elements instead of empty strings.\"]}),(0,e.jsxs)(a.p,{children:[\"So on my above example URL with the utm_campaign parameter in the hash, the data element \",(0,e.jsx)(a.code,{children:\"utm_campaign_fallback\"}),\" is the first data element that contains a value. So the truthy chain data element will return that one. If the 'campaign_cookie' data element was defined, the truth chain would return that one since it appears in the list ahead of the utm fallback data element.\"]}),(0,e.jsx)(a.p,{children:`Using this approach in a data element keeps the \"checking\" logic out of my action code and allows me to look in multiple places for the same data. Of course, the most ideal setup would be to configure the site to send consistent data in the same way every time, but in today's modern society, that's not always possible.`}),(0,e.jsx)(a.p,{children:\"I use this truthy chain data element paradigm a lot. Maybe I should make an extension\\u2026\"})]})}}var w=b;return y(_);})();\n;return Component;"
  },
  "_id": "blog/chain-of-truth-using-truthy-data-elements.mdx",
  "_raw": {
    "sourceFilePath": "blog/chain-of-truth-using-truthy-data-elements.mdx",
    "sourceFileName": "chain-of-truth-using-truthy-data-elements.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/chain-of-truth-using-truthy-data-elements"
  },
  "type": "Blog",
  "readingTime": {
    "text": "4 min read",
    "minutes": 3.775,
    "time": 226500,
    "words": 755
  },
  "slug": "chain-of-truth-using-truthy-data-elements",
  "toc": [
    {
      "value": "The Problem",
      "url": "#the-problem",
      "depth": 2
    },
    {
      "value": "Example",
      "url": "#example",
      "depth": 2
    },
    {
      "value": "Using Fallbacks",
      "url": "#using-fallbacks",
      "depth": 2
    },
    {
      "value": "utm_campaign_parameter",
      "url": "#utm_campaign_parameter",
      "depth": 3
    },
    {
      "value": "utm_campaign_fallback",
      "url": "#utm_campaign_fallback",
      "depth": 3
    },
    {
      "value": "utm_campaign",
      "url": "#utm_campaign",
      "depth": 3
    },
    {
      "value": "Truthy Chain",
      "url": "#truthy-chain",
      "depth": 2
    },
    {
      "value": "campaign data element",
      "url": "#campaign-data-element",
      "depth": 3
    }
  ]
}
