{
  "title": "Syncing Adobe Launch/Tags with Github - Part 1: Setup",
  "date": "2023-04-30T00:00:00.000Z",
  "tags": [
    "adobe launch",
    "adobe tags",
    "javascript",
    "github",
    "automation"
  ],
  "draft": false,
  "summary": "How to use Github to build, sync, & deploy custom code data elements part 1",
  "body": {
    "raw": "\n## Down the rabbit hole\n\nI originally just wanted to sync one github file with one data element and bake some _real_\nversion control into my data elements. Not that they change that often, but hey, some do,\nespecially when you start enhancing existing libraries that Launch is responsible for. For example,\nscripts that add visitor metadata to chat applications, or functions that trigger Qualtrics Site Intercept popups\nare the first things that come to mind. Plus, this is just cool and something I always figured was possible and\nthat someone other than me would do it. Well, in true _sua sponte_ manner, I just did it myself.\n\n_Everything here should be considered proof of concept! I am not responsible if you start syncing directly\nto production! Proceed with caution!_\n\n## So how exactly does it work?\n\nMore hooks than a bait shop, more callbacks than a...teenager with a busted voicemail? I don't know I couldn't think of anything. Here is how it works:\n\n- Initial Setup of data elements in Launch and files in Github\n- Github push webhook sends a push event to an API gateway. I'll call this the **Webhook Gateway**.\n  - _API is protected & verified via github personal access token_\n- The **Webhook Gateway** checks the push for relevant files,\n  - _don't want to update launch when someone updates `README.md`_\n  - don't want to proceed if ldflsjflsjfdlsj\n- Once the push is verified, the **Webhook Gateway** invokes a lambda that calls the Github API and pulls the actual contents of the file(s) that were pushed. This is called **Extract Github Data**.\n- **Extract Github Data** does exactly what it sounds like, it gets the actual code that I'm going to push to Launch. More importantly, it extracts the data element IDs which are stored in the Github file in order to sync the file with Launch.\n  - Don't worry about exposing these IDs, a minified Launch library strips comments out so the Data element IDs won't be visible\n- Once the file contents and data element IDs are extracted, **Extract Github Data** invokes another lambda that starts talking to Launch. I'll call this **Build Launch Development Library**\n- **Build Launch Development Library** takes the new data from Github with corresponding data element IDs and updates the data elements, and builds a development Launch library with the new changes.\n  - This part took me the longest to figure out\n- Now, I _could_ stop here with a built dev library that I can go in and publish on my own, but where is the fun in that? To take this project to its full potential. I made a Launch callback endpoint that will push changes from Github (and only ones from Github) directly to Prod.\n",
    "code": "var Component=(()=>{var c=Object.create;var h=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(n,i)=>()=>(i||n((i={exports:{}}).exports,i),i.exports),g=(n,i)=>{for(var a in i)h(n,a,{get:i[a],enumerable:!0})},l=(n,i,a,t)=>{if(i&&typeof i==\"object\"||typeof i==\"function\")for(let o of u(i))!p.call(n,o)&&o!==a&&h(n,o,{get:()=>i[o],enumerable:!(t=d(i,o))||t.enumerable});return n};var w=(n,i,a)=>(a=n!=null?c(m(n)):{},l(i||!n||!n.__esModule?h(a,\"default\",{value:n,enumerable:!0}):a,n)),f=n=>l(h({},\"__esModule\",{value:!0}),n);var r=b((D,s)=>{s.exports=_jsx_runtime});var x={};g(x,{default:()=>I,frontmatter:()=>y});var e=w(r()),y={title:\"Syncing Adobe Launch/Tags with Github - Part 1: Setup\",date:\"2023-04-30\",tags:[\"adobe launch\",\"adobe tags\",\"javascript\",\"github\",\"automation\"],draft:!1,summary:\"How to use Github to build, sync, & deploy custom code data elements part 1\"};function k(n={}){let{wrapper:i}=n.components||{};return i?(0,e.jsx)(i,Object.assign({},n,{children:(0,e.jsx)(a,{})})):a();function a(){let t=Object.assign({h2:\"h2\",a:\"a\",span:\"span\",p:\"p\",em:\"em\",ul:\"ul\",li:\"li\",strong:\"strong\",code:\"code\"},n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(t.h2,{id:\"down-the-rabbit-hole\",children:[(0,e.jsx)(t.a,{\"aria-hidden\":\"true\",href:\"#down-the-rabbit-hole\",tabIndex:\"-1\",children:(0,e.jsx)(t.span,{className:\"icon icon-link\"})}),\"Down the rabbit hole\"]}),(0,e.jsxs)(t.p,{children:[\"I originally just wanted to sync one github file with one data element and bake some \",(0,e.jsx)(t.em,{children:\"real\"}),\" version control into my data elements. Not that they change that often, but hey, some do, especially when you start enhancing existing libraries that Launch is responsible for. For example, scripts that add visitor metadata to chat applications, or functions that trigger Qualtrics Site Intercept popups are the first things that come to mind. Plus, this is just cool and something I always figured was possible and that someone other than me would do it. Well, in true \",(0,e.jsx)(t.em,{children:\"sua sponte\"}),\" manner, I just did it myself.\"]}),(0,e.jsx)(t.p,{children:(0,e.jsx)(t.em,{children:\"Everything here should be considered proof of concept! I am not responsible if you start syncing directly to production! Proceed with caution!\"})}),(0,e.jsxs)(t.h2,{id:\"so-how-exactly-does-it-work\",children:[(0,e.jsx)(t.a,{\"aria-hidden\":\"true\",href:\"#so-how-exactly-does-it-work\",tabIndex:\"-1\",children:(0,e.jsx)(t.span,{className:\"icon icon-link\"})}),\"So how exactly does it work?\"]}),(0,e.jsx)(t.p,{children:\"More hooks than a bait shop, more callbacks than a...teenager with a busted voicemail? I don't know I couldn't think of anything. Here is how it works:\"}),(0,e.jsxs)(t.ul,{children:[(0,e.jsx)(t.li,{children:\"Initial Setup of data elements in Launch and files in Github\"}),(0,e.jsxs)(t.li,{children:[\"Github push webhook sends a push event to an API gateway. I'll call this the \",(0,e.jsx)(t.strong,{children:\"Webhook Gateway\"}),\".\",(0,e.jsx)(t.ul,{children:(0,e.jsx)(t.li,{children:(0,e.jsx)(t.em,{children:\"API is protected & verified via github personal access token\"})})})]}),(0,e.jsxs)(t.li,{children:[\"The \",(0,e.jsx)(t.strong,{children:\"Webhook Gateway\"}),\" checks the push for relevant files,\",(0,e.jsxs)(t.ul,{children:[(0,e.jsx)(t.li,{children:(0,e.jsxs)(t.em,{children:[\"don't want to update launch when someone updates \",(0,e.jsx)(t.code,{children:\"README.md\"})]})}),(0,e.jsx)(t.li,{children:\"don't want to proceed if ldflsjflsjfdlsj\"})]})]}),(0,e.jsxs)(t.li,{children:[\"Once the push is verified, the \",(0,e.jsx)(t.strong,{children:\"Webhook Gateway\"}),\" invokes a lambda that calls the Github API and pulls the actual contents of the file(s) that were pushed. This is called \",(0,e.jsx)(t.strong,{children:\"Extract Github Data\"}),\".\"]}),(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.strong,{children:\"Extract Github Data\"}),\" does exactly what it sounds like, it gets the actual code that I'm going to push to Launch. More importantly, it extracts the data element IDs which are stored in the Github file in order to sync the file with Launch.\",(0,e.jsx)(t.ul,{children:(0,e.jsx)(t.li,{children:\"Don't worry about exposing these IDs, a minified Launch library strips comments out so the Data element IDs won't be visible\"})})]}),(0,e.jsxs)(t.li,{children:[\"Once the file contents and data element IDs are extracted, \",(0,e.jsx)(t.strong,{children:\"Extract Github Data\"}),\" invokes another lambda that starts talking to Launch. I'll call this \",(0,e.jsx)(t.strong,{children:\"Build Launch Development Library\"})]}),(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.strong,{children:\"Build Launch Development Library\"}),\" takes the new data from Github with corresponding data element IDs and updates the data elements, and builds a development Launch library with the new changes.\",(0,e.jsx)(t.ul,{children:(0,e.jsx)(t.li,{children:\"This part took me the longest to figure out\"})})]}),(0,e.jsxs)(t.li,{children:[\"Now, I \",(0,e.jsx)(t.em,{children:\"could\"}),\" stop here with a built dev library that I can go in and publish on my own, but where is the fun in that? To take this project to its full potential. I made a Launch callback endpoint that will push changes from Github (and only ones from Github) directly to Prod.\"]})]})]})}}var I=k;return f(x);})();\n;return Component;"
  },
  "_id": "blog/github-sync-part1.mdx",
  "_raw": {
    "sourceFilePath": "blog/github-sync-part1.mdx",
    "sourceFileName": "github-sync-part1.mdx",
    "sourceFileDir": "blog",
    "contentType": "mdx",
    "flattenedPath": "blog/github-sync-part1"
  },
  "type": "Blog",
  "readingTime": {
    "text": "3 min read",
    "minutes": 2.295,
    "time": 137700,
    "words": 459
  },
  "slug": "github-sync-part1",
  "toc": [
    {
      "value": "Down the rabbit hole",
      "url": "#down-the-rabbit-hole",
      "depth": 2
    },
    {
      "value": "So how exactly does it work?",
      "url": "#so-how-exactly-does-it-work",
      "depth": 2
    }
  ]
}